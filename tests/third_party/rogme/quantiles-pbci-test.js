/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-env mocha */

import fs from 'fs';
import {strict as assert} from 'assert';

import {PROJECT_ROOT} from '../../../js/module-utils.js';
import {assertAlmostEqual} from '../../test-utils/floating-point-checks.js';
import {CsvParser} from '../../../js/csv-parser.js';
import {quantilesPbci} from '../../../third_party/rogme/quantiles-pbci.js';

const testFixtureTxt = fs.readFileSync(PROJECT_ROOT +
    '/tests/fixtures/paired-fcp-data.csv', 'utf-8');
/** @type {[number, number, number, number]} */
const xorshiftSeed = [1041628356, 1081053425, 395050667, 1356391169];

/** @typedef {import('../../../third_party/rogme/quantiles-pbci.js').DifferenceQuantile} DifferenceQuantile */

// TODO(bckenny): replace when we have a ready-made column-producing parser.
/**
 * @param {string} text
 * @return {{base: Array<number>, compare: Array<number>}}
 */
function csvColumns(text) {
  const rows = CsvParser.parseRows(text);

  assert.strictEqual(rows[0][0], 'base');
  assert.strictEqual(rows[0][1], 'compare');

  const base = [];
  const compare = [];
  for (let i = 1; i < rows.length; i++) {
    const row = rows[i];
    base.push(Number(row[0]));
    compare.push(Number(row[1]));
  }

  return {base, compare};
}

/**
 * @param {Array<DifferenceQuantile>} actual
 * @param {Array<DifferenceQuantile>} expected
 * @param {Record<keyof DifferenceQuantile, number>} maxAbsDiffByKey
 */
function assertDeciles(actual, expected, maxAbsDiffByKey) {
  assert.strictEqual(actual.length, 9);
  assert.strictEqual(expected.length, 9);

  for (let i = 0; i < expected.length; i++) {
    const actualDecile = actual[i];
    const expectedDecile = expected[i];
    assert.strictEqual(Object.keys(actualDecile).length, Object.keys(expectedDecile).length,
      `unequal number of properties between actual and expected in decile ${expectedDecile.q}`);

    for (const key of Object.keys(expectedDecile)) {
      const k = /** @type {keyof DifferenceQuantile} */ (key); // Make tsc happy.
      const assertOptions = {
        maxAbsDiff: maxAbsDiffByKey[k],
        message: `difference at decile ${expectedDecile.q}, key '${key}'`,
      };
      assertAlmostEqual(actualDecile[k], expectedDecile[k], assertOptions);
    }
  }
}

describe('quantilesPbci', () => {
  it('finds the quantiles for two arrays', () => {
    const base = Array(100).fill(0);
    // 0.5...99.5
    const compare = Array(100).fill(0.5).map((x, y) => x + y);

    const options = {nboot: 200, quiet: true, randomSeed: xorshiftSeed};
    const quantilesResults = quantilesPbci({base, compare}, options);

    // Simple-ish by construction.
    const expected = [
      {q: 0.1, difference: 10, ciLower: 6, ciUpper: 18},
      {q: 0.2, difference: 20, ciLower: 13, ciUpper: 28},
      {q: 0.3, difference: 30, ciLower: 21, ciUpper: 40},
      {q: 0.4, difference: 40, ciLower: 30, ciUpper: 50},
      {q: 0.5, difference: 50, ciLower: 41, ciUpper: 59},
      {q: 0.6, difference: 60, ciLower: 51, ciUpper: 69},
      {q: 0.7, difference: 70, ciLower: 61, ciUpper: 77},
      {q: 0.8, difference: 80, ciLower: 72, ciUpper: 86},
      {q: 0.9, difference: 90, ciLower: 83, ciUpper: 94},
    ];

    const maxAbsDiffByKey = {
      // Exact comparison for 'q'.
      q: 0,
      difference: 1e15,
      // CI bounds are much more dependent on nboot and rng. Set to appropriate
      // for difference magnitudes.
      ciLower: 0.5,
      ciUpper: 0.5,
    };

    assertDeciles(quantilesResults, expected, maxAbsDiffByKey);
  });

  it('throws if columns do not have the same length', () => {
    const base = [0, 1, 2, 3];
    const compare = [0, 1];

    assert.throws(() => {
      return quantilesPbci({base, compare}, {nboot: 200});
    }, /^Error: dependent `base` and `compare` must have the same length$/);
  });

  it('matches rogme quantiles_pbci output', () => {
    const data = csvColumns(testFixtureTxt);
    const options = {nboot: 20_000, quiet: true, randomSeed: xorshiftSeed};
    const quantilesResults = quantilesPbci(data, options);

    // Expectations generated by R/rogme-diff-deciles-pbci-bin.R with `nboot` of 20_000.
    /* eslint-disable max-len */
    const expected = [
      {q: 0.1, difference: -2406.7, ciLower: -2784.5, ciUpper: -1963.5},
      {q: 0.2, difference: -1541.1, ciLower: -1897.9, ciUpper: -1314.6},
      {q: 0.3, difference: -1199.7, ciLower: -1353.6, ciUpper: -1086.8},
      {q: 0.4, difference: -1026.2, ciLower: -1130.3, ciUpper: -903.5},
      {q: 0.5, difference: -817.1, ciLower: -970.1, ciUpper: -638.4},
      {q: 0.6, difference: -564.8, ciLower: -723, ciUpper: -440.7},
      {q: 0.7, difference: -377.5, ciLower: -489.4, ciUpper: -222.6},
      {q: 0.8, difference: -79, ciLower: -269.6, ciUpper: 126.5},
      {q: 0.9, difference: 582.6, ciLower: 174.3, ciUpper: 1269},
    ];
    /* eslint-enable max-len */

    // R uses a different RNG, so allow enough difference in precision,
    // especially for the variable CI bounds.
    const maxAbsDiffByKey = {
      // Exact comparison for 'q'.
      q: 0,
      difference: 0.5,
      // CI bounds are much more dependent on nboot and rng. Set to appropriate
      // for difference magnitudes.
      ciLower: 6,
      ciUpper: 3,
    };

    assertDeciles(quantilesResults, expected, maxAbsDiffByKey);
  });
});
